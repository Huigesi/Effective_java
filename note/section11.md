

# 第11章 序列化

将对象编码成一个字节流，称作将该对象序列化

一旦对象被序列化，它的编码就可以从一台正在运行的虚拟机被传递到另一台虚拟机上，
或者储存到磁盘上，供以后反序列化时用。

## 第74条： 谨慎地实现Serializable接口

实现Serializable接口的最大代价是，大大降低了“改变这个类的实现”的灵活性

第二个代价是，它增大了出现Bug和安全漏洞的可能性。

第三个代价是，随着类发行新的版本，相关的测试负担也增加了。

## 第75条： 考虑使用自定义的序列化形式

不管选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显示的序列版本UID

    private static final long serialVersionUID=randomLongValue;
    
## 第76条： 保护性地编写readObject方法

当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，
就必须要做保护性拷贝，这是非常重要的。

## 第77条： 对于实例控制，枚举类型优于readResolve

readResolve特性允许你用readObject创建的实例代替另一个实例。

## 第78条： 考虑用序列化代理代替序列化实例

